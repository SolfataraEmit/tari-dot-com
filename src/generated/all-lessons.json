[
  {
    "slug": "09_adding_tari_to_your_exchange",
    "content": "\nIn this guide, we will cover the basics of getting a Minotari node operational and explain the process of setting up the associated wallets required to run Minotari on your exchange securely:\n\n-   We will set up your own Minotari node\n-   We will cover the creation of a Minotari wallet as the store of funds, as well as a corresponding read-only wallet for use by the exchange for monitoring transactions\n-   We will discuss how to monitor the blockchain for transactions\n-   We will cover both the depositing and withdrawal of funds to the wallet\n\nThis guide assumes that the node will not be used for mining.\n\n## Node Setup\n\nIn order to accept Tari, you will need to have a Minotari node. While it is possible to use a public node with the correct gRPC methods exposed to the internet, it is recommended that you run your own node.\n\nIt may also be worth running multiple nodes as backups to ensure availability.\n\n> Note: For all servers connected to the internet, they must either be running a Tor client or configure their public IP information. Documentation on this is available [here](https://github.com/tari-project/tari#README) and [here](https://github.com/tari-project/tari/discussions/6366). If you are running on Linux, the Tari applications have built-in Tor support, so this can be ignored.\n\n### Section 1: Create a Minotari Node and run it\n\nThe Minotari node is the base layer node required to receive and monitor transcations.\n\n> NOTE: If you are using a public Minotari node, you can skip this section. Note that you will need the `public key` and the `public address` of the public node in question in order to correctly proceed with this exchange guide.\n\n1. Download the compiled binaries [here](https://tari.com/downloads/). If you would prefer to compile from source, you will need to follow the instructions located [here.](https://github.com/tari-project/tari#building-from-source)\n\n2. Use the instructions here to [install the binaries](https://github.com/tari-project/tari?tab=readme-ov-file#installing-using-binaries).\n\n> NOTE: Depending on your environment, the location of the installed files will likely change. For Mac and Linux, you will likely find it in your Home directory in a `.tari` folder. It may be hidden, in which case you will need to change your settings to be able to view hidden files. On Windows, it will install on in the location you specified during the installation process. To have Minotari create the folder in a specific location, you can use the `--b` path command. Note that you will require this command going forward if you are not using the default folder.\n\nThe following binaries will be available.\n\n-   minotari_console_wallet\n-   minotari_merge_mining_proxy\n-   minotari_miner\n-   minotari_node\n-   randomx-benchmark\n-   randomx-codegen\n-   randomx-tests\n\nThe two required for the exchange are the **minotari_node** and **minotari_console_wallet**\n\n3. Start the node (consecutive runs):\n\n```\nminotari_node\n```\n\nIf a node has not yet been created, it will inform you that a node config file does not exist. You will also be asked if you wish to mine. Select `n` in this case.\n\n4. Next, you'll be asked if you wish to create a node identity. Select `y`. This is essential for generating the private/public key pair and getting the node recognised by the network.\n\nOnce done, the Minotari base node will boot up. You'll see a splash page with a list of the various Command Mode (accessible via Ctrl+C) commands available to you. Some useful ones are:\n\n-   `watch status`: returns you to the auto-refresh status from the Command Mode\n-   `version`: which version of the Minotari Node you are running\n-   `whoami`: provides address information related to the node\n\n5. Type `whoami` and press enter. You'll see your Public Key, Node ID and Public Address, along with a QR Code. You should copy this data to a file or secure location for future reference.\n\n```\n18:46 v1.0.0-pre.16 esmeralda State: Listening Tip: 3872 (Tue, 23 Jul 2024 14:27:53 +0000) Mempool: 0tx (0g, +/- 0blks) Connections: 0|0 Banned: 0 Messages (last 60s): 0 Rpc: 0/100 ️🔌\n>> whoami\nPublic Key: 90f67a04edcb36261e6304ca213629d183c44e26bd47e38c253473f44d901733\nNode ID: e8ed9a4fd38577b6b01e3b8e9d\nPublic Addresses: /onion3/f5qbkkfkoxowzvshe5mppzpgiiy76cwumpsacungeldoal6hehcgzfqd:18141\nFeatures: PeerFeatures(MESSAGE_PROPAGATION | DHT_STORE_FORWARD)\n```\n\n6. Restart the node (Ctrl+C twice to quit, then typing `minotari_node` again).\n\n### Section 2: Creating a wallet\n\nIn this section we'll create a wallet address for receiving funds. This wallet will serve as the main repository of your Tari coins.\n\n> NB: This is a crucial step in the process. Creating the wallet in secure environment and following the instructions is important to secure this wallet and prevent malicious actors being able to transfer Tari. Read the instructions carefully. If there is any doubt regarding ANY part of the process, please contact the Tari Community for clarification and assistance.\n\nThe Minotari wallet creation process is reliant on a seed word phrase to generate the associated master key. This seed phrase also allows for the recovery of the wallet. The seed phrase is a 24-word phrases generated from a pre-defined list of words, which will be displayed during the process.\n\n> **WARNING: It is highly recommended this process is performed on a trusted machine that is disconnected from any other device or the Internet. The utmost caution should be taken in creating the wallet and noting and securing the seed phrase.**\n\n1. First, let's create a folder to hold all the wallet data.\n\n```\nmkdir tari_wallet_data\ncd tari_wallet_data\n```\n\n> Note: At multiple points in the sections covering the creation of the wallets, you will be directed to copy or note seed phrases, keys and other information. Do not store any of these within the created folder above, as you will need to delete this folder permanently in later steps.\n\n2. Now let's run the wallet. Make sure that you specify the `--base-path` field to keep all the data in the above folder so that you can delete it afterwards.\n\n```\nminotari_console_wallet --base-path ~/tari_wallet_data\n```\n\n3. You'll be presented with a menu. As this guide assumes you are setting up Minotari for the first time, select `1`\n\n```\nConsole Wallet\n\n1. Create a new wallet.\n2. Recover wallet from seed words or hardware device.\n3. Create a read-only wallet using a view key.\n>>\n```\n\n4. You will be asked if you want to mine. Choose `n`\n\n```\nNode config does not exist.\nWould you like to mine (Y/n)?\nNOTE: this will enable additional gRPC methods that could be used to monitor and submit blocks from this node.\n```\n\n5. You will be asked if you wish to use a connected hardware wallet. Press `n` here.\n\n```\nWould you like to use a connected hardware wallet? (Supported types: Ledger) (Y/n)\n```\n\n6. Next you will be asked for a password. You will need to save this password for future use. Enter this password now, and then again to confirm it. Be meticulous when doing so. We recommend following best practices to generating a strong password.\n\n> NOTE: You will not see the password as you type it.\n\n7. **This next step is vital. Be sure that no information leaks and that the seed phrase is only visible to yourself and/or trusted parties.** Following entry of the password, you will be presented with your seed words. Carefully note the seed words, write them down and secure them. Make sure you have appropriate, equally secure backups. You will only be able to proceed to the next step once you have typed `confirm` and pressed `Enter`.\n\n```\n=========================\n       IMPORTANT!\n=========================\nThese are your wallet seed words.\nThey can be used to recover your wallet and funds.\nWRITE THEM DOWN OR COPY THEM NOW. THIS IS YOUR ONLY CHANCE TO DO SO.\n\n=========================\n<...............seed words will be presented here.............>\n=========================\n\nI confirm that I will never see these seed words again.\nType the word \"confirm\" to continue.\n>>\n```\n\n8. At this point, the Minotari wallet will launch in the console interface.\n\n> Note: The following sections deal with configuration of the wallet. While not necessary, an extra safety precaution would be to confirm that the seed words you copied can actually recover the wallet.\n\n### Section 3: Obtain the addresses of the main wallet\n\nNow that we have the wallet created, we will require the addresses - specifically, the `Tari Address one-sided` - to create the second wallet, which will be used to monitor transactions.\n\nIf you followed the instructions from the previous section, you should already be in the Minotari console wallet interface. If not, run `minotari_console_wallet --base-path ~/tari_wallet_data` and enter in your password to launch the interface.\n\n1. While in the wallet interface, press the right arrow twice to get to the `Receive` tab. This tab will list all of the addresses associated with the wallet.\n\n![Tari Exchange Guide - Wallet Addresses](../assets/lessons/img/tariexchangeguide/tariexchangeguide_wallet_addresses.png)\n\n2. Copy all of the information provided, with special note of the `Tari Address one-sided` field. This is the address that users will send funds to for the exchange.\n\n3. Press `f10` or `Ctrl+Q` to exit the wallet\n\n4. Next, we'll export the view key for the wallet (We'll use this in **Section 4**). Run the following command and enter in your wallet password when prompted.\n\n```\nminotari_console_wallet --base-path ~/tari_wallet_data export-view-key-and-spend-key\n```\n\nYou'll be presented with information that looks similar to the below:\n\n```\n1. ExportViewKeyAndSpendKey(ExportViewKeyAndSpendKeyArgs { output_file: None })\n\nView key: cb6c13f07af23380c7756bbfcd622bc3277ec2cc42abd5ed3d8ddd19fa49060c\nSpend key: f29039796b3430c6927f26bf216b6241dd7fad7f30a6640e8ac95f3d0af51a52\nMinotari Console Wallet running... (Command mode completed)\n\nPress Enter to continue to the wallet, or type q (or quit) followed by Enter.\n```\n\n5. Make note of the `view key` and `spend key`; copy them to an easily referenced place. We will require them in later steps.\n\n6. Type `q` and then press `Enter` to exit the console wallet.\n\n7. Make sure you have saved the above data. Permanently delete the folder `tari_wallet_data` and consider destroying or securely wiping the machine.\n\n> Note: Now is a good time to check your noted keys, seed words and addresses before remove the configuration data in the folder and/or destroying/wiping the device.\n\n### Section 4: Setting up a read-only wallet to receive deposits\n\nIn this section, we will create a second, read-only wallet that will watch for funds received at the address saved in the previous section. If you are integrating an exchange, this is how you can watch for received funds. This wallet will need to be able to access the Internet in some capacity.\n\n> NOTE: This second wallet will not have the ability to spend any funds. While this limits the security risk, it is good practice to maintain security best practices when configuring any system that has access to the chain and has some association with the the main wallet.\n\n1. On a server machine that is connected to the internet. Run this command `minotari_console_wallet` to create a wallet.\n\n> Note: By default all data is stored in `~/.tari`. You can find all logs, config and data in there. If you would like to use a specific folder, you can use the `--base-path` argument to point to an existing folder or one you've created prior for this purpose.\n\n2. You will be asked if you want to mine. Choose `N`\n\n```\nNode config does not exist.\nWould you like to mine (Y/n)?\nNOTE: this will enable additional gRPC methods that could be used to monitor and submit blocks from this node.\n```\n\n3. Next, you will be asked if you want to create a new wallet, restore it, or create a read-only wallet using a view key. We want to create a _read-only wallet_, so we will select `3` here.\n\n```\nConsole Wallet\n\n1. Create a new wallet.\n2. Recover wallet from seed words or hardware device.\n3. Create a read-only wallet using a view key.\n>>\n```\n\n4. Next we will be asked for a password. You will need to save this password for future use. Enter this password now and confirm it.\n\n> Note: It is suggested you use a different password here from the one used to create the first wallet.\n\n5. You will need to enter the view and spend keys noted in **Section 4**\n\n```\nEnter view key:  (hex)\n<...view key here...>\n\nEnter the public spend key:  (hex or base58)\n<...public spend key here...>\n```\n\n6. You should now see the familiar console wallet. We'll need to configure it further in its accompanying configuration file, so close it for now by pressing `f10` or `Ctrl+Q` and move onto the next section.\n\n### Section 5: Configuring the read-only wallet\n\n1. Browse to the config file under `~/.tari/mainnet/config/config.toml` (or the folder where you specified the wallet configuration should be stored) and open it in your favourite text editor.\n\n2. Find the section `Wallet Configuration Options (WalletConfig)`. Below is a typical example of the beginning of the wallet configuration section within the `config.toml` file.\n\n```toml\n########################################################################################################################\n#                                                                                                                      #\n#                      Wallet Configuration Options (WalletConfig)                                                     #\n#                                                                                                                      #\n########################################################################################################################\n\n[wallet]\n# The buffer size constants for the publish/subscribe connector channel, connecting comms messages to the domain layer:\n# (min value = 300, default value = 50000).\n#buffer_size = 50000is\n```\n\n3. Next, find the line `#grpc_enabled = false` and change it to `grpc_enabled = true`. You will also need to uncomment the `grpc_address`.\n\n> Note: If you wish to secure the gRPC more, you can edit the other settings, such as the `grpc_authentication`. It is important that the wallet's gRPC port is not accessible from the public internet\n\n```toml\n# Set to true to enable grpc. (default = false)\ngrpc_enabled = true\n# The socket to expose for the gRPC base node server (default = \"/ip4/127.0.0.1/tcp/18143\")\ngrpc_address = \"/ip4/127.0.0.1/tcp/18143\"\n# gRPC authentication method (default = \"none\")\n#grpc_authentication = { username = \"admin\", password = \"xxxx\" }\n```\n\n4. Set the wallet's base node. Set this value to the `minotari_node` you created or chose at the beginning of this guide in **Section 1**.\n\n> Note: The format is `<...public key...>::<...public address...>`, with <...> being replaced with the addresses noted previously. Below is a sample of what these configuration settings look like, using the example data from **Section 1**. You should not use the data below, but insert your own details.\n\n```toml\n# A custom base node peer that will be used to obtain metadata from, example\n# \"0eefb45a4de9484eca74846a4f47d2c8d38e76be1fec63b0112bd00d297c0928::/ip4/13.40.98.39/tcp/18189\"\n# (default = )\ncustom_base_node = \"22d33b525d35d256674c5184c262b70d15275effcf5f6fe6dc0d359a18541d04::/onion3/6x54mmubphz5r3opswpuhseswivvlaxbohuqvwsn4o36zmtudq73dgid:18141\"\n```\n\n5. Save the file and start the wallet again.\n\n```\nminotari_console_wallet\n```\n\nYou are now ready to receive deposits. In the next section we'll explain how to listen for incoming transactions.\n\n### Section 6: Listening for incoming transactions\n\nHow you listen for incoming transactions (and what you do with them) will depend on your process. For our example, we'll use the gRPC server that is hosted in the read-only wallet we just created to listen for incoming deposits.\n\nReach out to us if you would like an example in your favourite language. You can find more information about the methods available in [wallet.proto here](https://github.com/tari-project/tari/blob/development/applications/minotari_app_grpc/proto/wallet.proto).\n\n```javascript\nconst grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\n\n// Load the protobuf\nconst PROTO_PATH = './proto/wallet.proto';\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n});\nconst streamingProto = grpc.loadPackageDefinition(packageDefinition).tari.rpc;\n\n// Create a client\nconsole.log(streamingProto);\nconst client = new streamingProto.Wallet('localhost:18143', grpc.credentials.createInsecure());\n\nconst request = {};\n\n// Call the gRPC method\nconst call = client.GetCompletedTransactions(request);\n\n// Handle the stream of responses\ncall.on('data', (response) => {\n    console.log('Received data:', response);\n    // ..... Do business logic with transaction. E.g. compare the reference in payment_id to a reference provided to the exchange client and allocate\n    // to their account\n    // ....\n});\n\ncall.on('end', () => {\n    console.log('Stream ended.');\n});\n\ncall.on('error', (err) => {\n    console.error('Stream error:', err);\n});\n\ncall.on('status', (status) => {\n    console.log('Stream status:', status);\n});\n```\n\nThis is a basic implementation; some additional items you may want to consider for a production environment are:\n\n-   Using `grpc.credentials.createSsl()` to secure the connection between the wallet and any application calling it. We'll not discuss the process of creating a server key or certificate here; you can read more about the process [here](https://www.ibm.com/docs/en/api-connect/10.0.x?topic=profile-generating-self-signed-certificate-using-openssl). Below is an example:\n\n```javascript\n// Load the protobuf definition\nconst PROTO_PATH = './proto/wallet.proto';\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n});\nconst streamingProto = grpc.loadPackageDefinition(packageDefinition).tari.rpc;\n\n// Read the server's certificate (server.crt)\nconst serverCert = fs.readFileSync('path/to/server.crt'); // Specify the path to your server's certificate\n\n// Create secure credentials for the client using the server's certificate\nconst credentials = grpc.credentials.createSsl(serverCert);\n\n// Create the gRPC client with the secure credentials\nconst client = new streamingProto.Wallet('localhost:18143', credentials);\n\n// Prepare the request object (you can modify this based on the method's requirements)\nconst request = {};\n\n// Call the gRPC method with secure connection\nconst call = client.GetCompletedTransactions(request);\n\n// Handle the stream of responses\ncall.on('data', (response) => {\n    console.log('Received data:', response);\n    // Process transaction data here. Example:\n    // Compare the reference in payment_id to a reference provided to the exchange client and allocate to their account\n});\n\ncall.on('end', () => {\n    console.log('Stream ended.');\n});\n\ncall.on('error', (err) => {\n    console.error('Stream error:', err);\n});\n\ncall.on('status', (status) => {\n    console.log('Stream status:', status);\n});\n```\n\n## Descriptions of Common Activities\n\n### Section 7: An example for receiving funds\n\nEach exchange will have their own processes, but here is an example of receiving funds from a KYC'ed client.\n\n1. The client begins the deposit process. For example, clicking on a \"Deposit\" button.\n\n2. The exchange generates a long unique ID for the deposit. This may be a single reference that is reused for the client, or every deposit may have their own reference.\n\n3. The exchange provides their `Tari Address one-sided` address and the reference to the client. The exchange must also save this reference in their internal database.\n\n> Note: Exchanges should use the one-sided or non-interactive addresses so they can receive deposits even if their infrastructure is offline. Interactive addresses are intended for peer-to-peer transactions.\n\n4. The client uses Tari Aurora or another Tari-enabled wallet and sends a non-interactive transaction to the provided address. They must include the provided reference with this transaction.\n\n> Note: Using the Minotari console wallet, for example, the recommendation would be for the user to place your payment reference in the `Payment ID` field.\n\n5. A process similar to the example in **Section 6**, the exchange periodically runs the script to see if there are any new transactions.\n\n6. For new transactions, compare against the list of expected references in their internal database and if there is a match, call the internal system to allocate funds to the client's account.\n\n### Section 8: Performing withdrawals\n\nIn this section we'll perform a withdrawal from the same address we used in **Section 3**. It is also possible to have a number of different wallets and send funds between them. The process is mostly the same, but is out of scope for this document.\n\n> NOTE: The wallet used to spend funds should not be online for more time than is necessary. It is recommended that the machine running this wallet is secured.\n\nBefore we spend funds, we must have a wallet set up with the seed words created in Step 7 of **Section 2**.\n\nOnce the wallet is set up, continue with the steps below.\n\n1. Run the wallet to update the balance\n\n```\nminotari_console_wallet --password <password> -p \"wallet.custom_base_node=<...node_pub_key...>::<...node_pub_address...>\" --auto-exit sync\n```\n\n> Note: The custom base node can also be set as an environment variable `TARI_WALLET__CUSTOM_BASE_NODE`\n\n2. Validate there are sufficient funds in the wallet\n\n```\nminotari_console_wallet --password <password> -p \"wallet.custom_base_node=<...node_pub_key...>::<...node_pub_address...>\" --auto-exit get-balance\n```\n\n```\nMinotari Console Wallet running... (Command mode started)\n==============\nCommand Runner\n==============\n\n1. GetBalance\n\nAvailable balance: 10000.000000 T\nTime locked: 0 µT\nPending incoming balance: 27960.980255 T\nPending outgoing balance: 0 µT\n\nMinotari Console Wallet running... (Command mode completed)\n```\n\n3. Next, send funds to the desired address.\n\n```\nminotari_console_wallet --password <password> -p \"wallet.custom_base_node=<node_pub_key>::<node_pub_address>\" --auto-exit send-minotari <amount> <destination>\n```\n\nReplace `<amount>` and `<destination>` with the amount to send and Tari address to send funds to. Note: The amount is specified in units of 0.000001 XTM. To specify the amount in Tari, you can append the letter `T`. For example, `send-minotari 10000` would send an amount of `0.01 XTM`. `send-minotari 10000T` would send an amount of `10000 XTM`.\n\nExchanges should not allow clients to provide interactive Tari Addresses. This can be easily validated by checking the second byte of the address. Specifically, the byte that represents an interactive wallet would be 01 in hexadecimal, or 00000001 in binary.\n\nTo break it down:\n\n-   The value is 01 (hexadecimal)\n-   In binary, this is 00000001\n-   The least significant bit (rightmost bit) is 1, indicating support for interactive transactions\n",
    "title": "Adding Tari to Your Exchange",
    "order": 0,
    "excerpt": "In this guide, we will cover the basics of getting a Minotari node operational and explain the process of setting up the associated wallets required to run Minotari on your exchange securely: -   We...",
    "thumbnail": "/assets/lessons/img/placeholder-thumbnail.jpg",
    "author": "stringhandler"
  },
  {
    "slug": "08_setting_up_development_environment",
    "content": "\nThe following guide will take you through setting up an appropriate development environment on your local machine so you can work with Tari’s various projects. We'll use Tari Universe as the project example to cover elements such as forking and cloning, but you should be able to apply this to any of the [Tari projects](https://github.com/tari-project).\n\nIn this guide, we’ll cover:\n* Setting up a GitHub account\n* Installing VS Code as your integrated development environment (IDE)\n* Installing development prerequisites (Git, Rust and nvm)\n* Setting up your credentials to easily work in GitHub using SSH\n* Forking a repository you are interested in contributing to\n* Cloning the repository on your local machine\n\n## Step 1 - Create your GitHub account\nIf you already have a GitHub account, you can skip this step. To sign up to GitHub, follow the instructions provided [at GitHub’s documentation site](https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github).\n\nWhile the steps may vary over time, you will need to perform the following actions:\n* Provide your desired username, password, and email address\n* Verify your email address\n\nOnce you’re done, you’ll be redirected to the GitHub dashboard.\n\nA useful introduction to basic development concepts is the [Hello World tutorial provided by GitHub](https://docs.github.com/en/get-started/start-your-journey/hello-world). This tutorial introduces new users to the basics of development within GitHub and covers basic concepts such as repos, branches, commits, and more.\n\n## Step 2 - Installing your IDE\nAn IDE is a software application that provides various tools and functions for editing code and managing development projects. There are many different IDEs available for use, but we will be using VS Code for the guide.\n\nRather than explain the exact process for installing VS Code, it is best to follow the official instructions for installing VS Code, as the installation steps may change over time and differ for different environments.\n\nUse one of the following links below, depending on your operating system, to install VS Code:\n[Linux: https://code.visualstudio.com/docs/setup/linux](https://code.visualstudio.com/docs/setup/linux)\n[MacOS: https://code.visualstudio.com/docs/setup/mac](https://code.visualstudio.com/docs/setup/mac)\n[Windows: https://code.visualstudio.com/docs/setup/windows](https://code.visualstudio.com/docs/setup/windows)\n\nFollow the instructions, then launch VS Code to confirm it’s working as intended. Next, we’ll install the prerequisites for working on Tari projects.\n\n## Step 3 - Installing Development Prerequisites\nWhile an IDE is generally the only thing you would require if you were programming your own small projects, modern development environments rely heavily on several applications and services that improves the overall process of development:\n\nBelow we’ve listed several items which will be useful to have when working with Tari projects.\n\n* [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)\n* [Nvm (for Node.js and npm)](https://github.com/nvm-sh/nvm).\n* MacOS: [Homebrew](https://brew.sh/).\n* [Rust language](https://www.rust-lang.org/tools/install)\n* [Protocol Buffers](https://grpc.io/docs/protoc-installation/)\n* [Cmake](https://cmake.org/download/) and make\n* [OpenSSL](https://docs.openssl.org/3.2/man7/ossl-guide-introduction/#getting-and-installing-openssl)\n* [Perl]https://learn.perl.org/installing/\n* LLVM\n* Tor (Optional)\n\nIt’s best to follow the official instructions for installing these items. We’ve linked to each one’s current installation page as a quick reference. Also note that you might already have some of these prerequisites installed. You can [also review the Tari home page for additional requirements](https://github.com/tari-project/tari)\n\n> :bulb: **Tip:** Check each project’s page for the command to check the version - this is usually the quickest method to find out if the application is installed or not.\n\n> :bulb: **Tip:** Note that there is a distinction between installing things *globally* and *locally*. The above projects are generally fine to install on a global level. However, project dependencies are a different story - if you are working with two repos, and both use a different version of a dependency, there's usually no way to cleanly install a global version for both. That's where package managers like npm come in to handle local dependencies on a case-by-case basis.\n\n## Step 4 - Setting up your GitHub access in VS Code\nTo simplify the process of working with your GitHub repositories, the typical means for doing so is via GPG and SSH. SSH is primarily used for authenticating while GPG is used for signing your commits - in other words, when you make changes, you'll be signing them so others can confirm it's actually you making the changes.\n\nThese are the preferred method for committing code to the Tari repos. Both SSH and GPG work by generating a private and public key that can then be used to interact securely with GitHub.\n\n* To set up SSH, you should refer to [the following guide](https://docs.github.com/en/authentication/connecting-to-github-with-ssh)\n* To set up GPG, you should refer to [this guide](https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key)\n\n## Step 5 - Forking the Tari Universe repo\nNext, we will fork the Tari Universe repo. Forking allows you to create your copy of the Tari Universe codebase, independent of the original project. This will allow you to safely modify the codebase without impacting the main project.\n\nMake sure you are logged into your GitHub account, then navigate to the Tari Universe repo here. Look to the top-right corner of the screen for the Fork button.\n\n<img src=\"../assets/lessons/img/adding-languages/forking_process.png\" width=600>\n\nClick on the drop-down and note the forks available. It should be blank. Click on the Create a new fork option to bring up the **Create a new fork** form.\n\n<img src=\"../assets/lessons/img/adding-languages/new_fork_form.png\" width=600>\n\nWhen filling out the form, keep the following in mind:\n* The owner should be your GitHub username\n* The repo name will be automatically filled in based on the repo name from the existing project. Leave it as is.\n* You can provide a description of the project. Descriptions and comments are a good habit to get into, so fill this out with a suitable description.\n* Make sure the **Copy the main branch only** option is checked. If you uncheck the option, you will copy all available branches from the existing repo.\n\nClick the **Create fork button** to continue.\n\nOnce you’ve done so, there’ll be a brief delay while GitHub creates the fork, then you’ll be redirected to the new fork’s home page. Look at the top-left corner, and you should see something that reads [Your Username]/[Your Repo Name]. This is a good way to check that you are on the right repo. Additionally, you’ll see a message under the repo that reads, “forked from tari-project/universe” and is a quick indicator that you’re on your fork.\n\n## Step 6 - Cloning your repository in VS Code\nOkay, so now that we have your GitHub credentials set up and available for VS Code, we’ll create a local repository - essentially a local version of the repo we created in GitHub - by cloning it.\n\nThis is a good time to start developing good practices around organizing your projects. We’d recommend creating a folder where you’d like to store your repository (call it something appropriate, like Repos or Repositories). Then, within that folder, create another folder called “universe-locale-project”. Make a note of their location, because this is where we’ll be cloning your repository to. \n\nIn VS Code, you have several options for cloning the repository, but the easiest way is to use the Command Pallete. Click on the View menu, and select “Command Pallete…”. You’ll also be able to see the shortcut here for your particular environment so you can use that to get to the Command Pallete in the future.\n\nIn the Command Pallete, Type “Git: Clone” and select the Git Clone option from the drop-down. You'll you’ll need to select a folder to put the local repository in.\n\n<img src=\"../assets/lessons/img/settingupenviro_lesson/clonefromgithub.png\" width=600>\n\nNext, enter the repository URL directly in the Command Pallete. In your forked GitHub repository, look to the top-right of the your project and locate the “Code <>” button, colored green. Clicking on the button will open a dialog box with the option to clone the repository via three methods. Select the SSH tab, and copy the string. It should look like **git clone git@github.com:yourusername/yourrepo.git**\n\nNow, navigate to the folder you created earlier and select it, then click the “Select as Repository Destination” button.\n\nThis will proceed to clone the repository. Once completed, you will be asked if you wish to open the project. When you do so, you’ll also receive a warning regarding the repository from VS Code.\n\nBecause you are dealing with code that can be executed as a normal application, this is informing you of the risks in doing so. Please select the “Yes, I trust the authors” button”. \n\nIf you are uncomfortable with trusting the repo, you can select the “No, I don’t trust the authors”, which result in VS Code accessing the folder via Restricted Mode ([you can read up more about this here](https://code.visualstudio.com/docs/editor/workspace-trust#:~:text=Restricted%20Mode%20tries%20to%20prevent,%2C%20workspace%20settings%2C%20and%20extensions.)).\n\nWhile doing so should not have a negative impact, note that this guide has been written with the assumption that you trust the project, so some functions or steps may not match up to your experience.\n\nOnce cloned, you will also be asked to install some recommended extensions in VS Code. These are not required for this guide, so you can skip installing them.\n\n## Step 7 - Adding the original Tari Universe Repository to your remotes.\nWe also need to add the original Tari Universe repository to your project. This is important because when you eventually start committing your new locale to your project, you will want to be able to feed those changes as recommendations to be incorporated into the main project.\n\nThis is commonly referred to as the Upstream repository - this represents the original project to which changes are made and releases are generated.\n\nIn VS Code, select the Source Control tab (this can be accessed via the View menu), and open up the Remotes panel. You should see only one item, called origin, in the list.\n\n <img src=\"../assets/lessons/img/settingupenviro_lesson/repoorigin.png\" width=600>\n\nTo add the Tari Universe repository as the upstream remote, hover over the Remotes header, and then click on the plus icon. You will be asked to provide a name for the remote repository - call it “Upstream”.\nS\nNext, you will require the Tari Universe URL from the main project. Go to https://github.com/tari-project/universe and copy the repository’s URL string in the same manner described in Step 5. Paste this URL into the field to add the repository, then select the “Add Remote and Fetch” option. You will now see the Tari Universe in your list of remote repositories.\n\n <img src=\"../assets/lessons/img/settingupenviro_lesson/remoterepo.png\" width=600>\n\n## You're Done!\nYou should now have your environment set up to start working on Tari's various projects. Check out [Tari's main page on GitHub](https://github.com/tari-project) to explore some of your options. We're excited to see what you can bring to the table.",
    "title": "Setting Up Your Development Environment",
    "order": 1,
    "excerpt": "The following guide will take you through setting up an appropriate development environment on your local machine so you can work with Tari’s various projects. We'll use Tari Universe as the project...",
    "thumbnail": "/assets/lessons/img/learn-the-tari-codebase.png",
    "author": "Solivagant"
  },
  {
    "slug": "07_add_new_localizations",
    "content": "\nAt Tari, our approach has always leaned towards greater usability. Tari Universe, our desktop mining app, provides an easy entry point for those unfamiliar with the more complicated aspects of setting up and mining Tari. Right now, Tari Universe has a limited number of languages available; with your help, we’d like to expand the selection.\n\nAdding a new language is a great way to dip your feet into the world of open-source projects, and requires minimal programming skills. Whether you're familiar with programming or are looking for a way to start familiarising yourself with development, this guide is for you. We’ll explain how to go about contributing new languages - or localizations - to Tari Universe. \n\n# Getting started\nTo contribute a localization, you’ll need these at the bare minimum:\n\n* A GitHub account\n* A fork of the Tari Universe repository.\n* Git\n\nHowever, this guide assumes the use of VS Code as your integrated development environment (IDE). This has some additional prerequisites, such as installing the IDE itself and supporting applications such as Git, nvm, Rust, and more.\n\nMost of the above is covered in our [“Setting up your development environment” guide](/lessons/08_setting_up_development_environment.html). If you're not already familiar with development practices and tools, this is a good place to start.\n\nIn this guide, we’ll cover the following:\n* Creating a GitHub account\n* Checking whether the localization you want to add already exists\n* Creating a fork of the Tari Universe project and new branch within your fork to begin working on the new localization.\n* Explain how localization works in Tari Universe\n* Explain the purpose of the different localization files and factors to keep in mind when translating.\n* Committing your localization for review and inclusion in Tari Universe via a pull request.\n\n## Step 1 - Create a GitHub account\nIf you already have a GitHub account, you can skip this step. To sign up to GitHub, follow the instructions provided [at GitHub’s documentation site](https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github).\n\nWhile the steps may vary over time, you will need to perform the following actions:\n* Provide your desired username, password, and email address\n* Verify your email address\n\nOnce you’re done, you’ll be redirected to the GitHub dashboard.\n\nA useful introduction to basic development concepts is the [Hello World tutorial provided by GitHub](https://docs.github.com/en/get-started/start-your-journey/hello-world). This tutorial introduces new users to the basics of development within GitHub and covers basic concepts such as repos, branches, commits, and more.\n\n## Step 2 - Check the current localizations\nBefore you start working, you need to check if the localization you want to add already exists or not. Go to the [Tari Universe project](https://github.com/tari-project/universe/tree/main/public/locales) and browse through the locales folders for currently available localizations.\n\nIf the one you wanted to add already exists, you can still contribute! Localization requires writers, proofreaders, and editors; all are necessary to ensure quality translations. You can simply work on an existing localization you're interested in. We’ll explain this in more detail from Step 5.\n\n## Step 3 - Forking the Tari Universe repo\nNext, we will fork the Tari Universe repo. Forking the Tari repo allows you to create your copy of the Tari Universe codebase, independent of the original project. This will allow you to safely modify the codebase without impacting the main project.\n\nMake sure you are logged into your GitHub account, then navigate to the Tari Universe repo **[here](https://github.com/tari-project/universe)**. Look to the top-right corner of the screen for the **Fork** button.\n\n<img src=\"../assets/lessons/img/adding-languages/forking_process.png\" width=600>\n\nClick on the drop-down and note the forks available. It should be blank. Click on the **Create a new fork** option to bring up the **Create a new fork** form.\n\n<img src=\"../assets/lessons/img/adding-languages/new_fork_form.png\" width=600>\n\nWhen filling out the form, keep the following in mind:\n* The owner should be your GitHub username\n* The repo name will be automatically filled in based on the repo name from the existing project. Leave it as is.\n* You can provide a description of the project. Descriptions and comments are a good habit to get into, so fill this out with a suitable description.\n* Make sure the **Copy the main branch only** option is checked. If you uncheck the option, you will copy all available branches from the existing repo, which will make things difficult to manage.\n\nClick the **Create fork** button to continue.\n\nOnce you’ve done so, there’ll be a brief delay while GitHub creates the fork, then you’ll be redirected to the new fork’s home page. Look at the top-left corner, and you should see something that reads **[Your Username]/[Your Repo Name]**. This is a good way to check that you are on the right repo. Additionally, you’ll see a message under the repo that reads, “forked from tari-project/universe” and is a quick indicator that you’re on your fork.\n\n<img src=\"../assets/lessons/img/adding-languages/new_fork_created.png\" width=600>\n\n## Step 4 - Creating a new branch for your localization work\nNow that you have your own fork of the project, you will need to create a new branch. Branching creates a copy of the code at a specific point in time, allowing you to work on your changes without impacting the work of others.\n\nOpen up VS Code, and ensure you have your repository open. If you're not sure what is meant by this, be sure to check out the [“How to Become a Tari Contributor” guide](/lessons/how_to_become_a_tari_contributor.html) and confirm you've completed the necessary steps before continuing.\n\n* At the bottom-left corner of VS Code’s status bar, click on the “main” branch. In the Command Palette at the top of VS Code, you will see that you have the option to create a new branch.\n* Select the **Create Branch** option and give it an appropriate name. The standard convention is to avoid spaces and use hyphens in their place; for example, “new-localization-esperanto”. If you are editing an existing localization, this might change to, for example, “proofreading-french-localization” or \"editing-french-airdrop-json\".\n* Once you’ve created the branch, you will notice that the status bar’s branch has been updated to whatever you called your new branch. However, you will still need to publish the new branch.\n* Click on the little cloud upload button next to the branch. In the Command Palette, you will have the option of publishing it to **Origin** or **Upstream**. Select **Origin**. You will now see the new branch in your list.\n\nCongratulations! You’re now ready to start working on your localization.\n\n## Step 5 - Getting to grips with Tari Universe's language system\nWhen launching for the first time, Tari Universe uses the user's system locale to determine which language the application should display. If the system locale is unavailable, the initial language displayed will be English.\n\nAvailable languages for Tari Universe are available in a drop-down within the **Settings → General Settings** section of the application. The user can also select to use the system’s language (or locale) to determine which language Tari Universe will use.\n\n<img src=\"../assets/lessons/img/adding-languages/settings_languages.png\" width=600>\n\nThese languages are derived from the Tari Universe project - specifically, from the ~/public/locales folder. Each locale consists of several JSON files stored in a folder that utilizes the [ISO-639 standard Set 1 two-letter naming convention](https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes) for languages. In VS Code, go to the Explorer Tab, expand the public/locales folder, then select the **en** locale folder.\n\n<img src=\"../assets/lessons/img/adding-languages/folder_structure.png\" width=600>\n\nIn addition, in order for the language to be available in the system, you'll need to update the **i18initializer.ts** file, located in src/i18initializer.ts. Here, you'll need to add your language and the regional variations associated with it so Tari Universe knows how to resolve different system configurations. If are working in an existing localization, you can skip this.\n\n### Step 5a - Understanding how the localization JSONs work\n\nEach JSON file corresponds to a different part of the app. Let’s have a look inside the **setup-view.json** file, which contains many of the start-up messages displayed when Tari Universe boots up:\n\n```json\n{\n    \"setting-up\": \"Setting up the Tari truth machine...\",\n    \"this-might-take-a-few-minutes\": \"This might take a few minutes\",\n    \"dont-worry\": \"Don't worry, next time it won't take as long\",\n    \"title\": {\n        \"starting-up\": \"Starting up\",\n        \"checking-latest-version-gpuminer\": \"Checking for latest version of xtrgpuminer\",\n        \"checking-latest-version-node\": \"Checking for latest version of node\",\n        \"checking-latest-version-mmproxy\": \"Checking for latest version of mmproxy\",\n        \"checking-latest-version-wallet\": \"Checking for latest version of wallet\",\n        \"checking-latest-version-xmrig\": \"Checking for latest version of xmrig\",\n        \"checking-latest-version-sha-p2pool\": \"Checking for latest version of sha-p2pool\",\n        \"waiting-for-wallet\": \"Waiting for wallet\",\n        \"waiting-for-node\": \"Waiting for node to sync\",\n        \"preparing-for-initial-sync\": \"Connecting to network peers {{initial_connected_peers}}/{{required_peers}}\",\n        \"starting-mmproxy\": \"Starting merge mining proxy\",\n        \"starting-p2pool\": \"Starting P2Pool\",\n        \"application-started\": \"Applications started\",\n        \"downloading\": \"Downloading\",\n        \"download-completed\": \"Download completed\",\n        \"waiting-for-header-sync\": \"Waiting for header sync. {{local_height}}/{{tip_height}} headers synced\",\n        \"waiting-for-block-sync\": \"Waiting for block sync. {{local_height}}/{{tip_height}} blocks synced\"\n    },\n    \"new-tari-version-available\": \"A new version of Tari Universe is available!\",\n    \"would-you-like-to-install\": \"Would you like to install Tari Universe {{version}} now?\",\n    \"yes\": \"Yes\",\n    \"no\": \"No\"\n}\n```\n\nAs we can see, **setup-view.json** consists of several variables that hook up to UI elements in Tari Universe. Text strings are stored against each variable, and Tari Universe displays that text. So while the variable name will always remain the same, the text string will change when a user selects a different locale.\n\nReturning to the contents, there are additional elements to consider. Looking at the **title** variable, note several additional fields associated with it in their own set of braces, starting with **starting-up** and continuing through to **waiting-for-block-sync**. The **title** variable is a property whose text will change depending on the state of the variable; in this case, as Tari Universe gets to a new setup step, the title text will change to reflect the step it is currently on.\n\nLastly, some of the strings have text enclosed in braces, such as the string, **“Would you like to install Tari Universe {{version}} now?”**. These are variables that Tari Universe calls and inserts into displayed text so it can be dynamically updated. When editing these messages, ensure these variables remain unaltered.\n\n### Step 5b - Understand how the i18initializer.ts file works\n\nAgain, you can skip this step if you are working on existing localizations. Below is a sample i18initializer.ts. We've limited it to two languages to keep the code snippet brief - the actual file will list all of the languages displayed.\n\n```\nimport i18n from 'i18next';\nimport { initReactI18next } from 'react-i18next';\nimport LanguageDetector from 'i18next-browser-languagedetector';\nimport HttpBackend from 'i18next-http-backend';\n\nexport enum Language {\n    PL = 'pl',\n    AF = 'af',\n}\n\n// System can have various regional variations for language codes, so we resolve them\nexport const resolveI18nLanguage = (languageCode: string): Language => {\n    switch (languageCode) {\n        case 'pl':\n        case 'pl-PL':\n            return Language.PL;\n        case 'af':\n        case 'af-ZA':\n        default:\n            return Language.EN;\n    }\n};\n\n// Language names for display\nexport const LanguageList: Record<Language, string> = {\n    [Language.PL]: 'Polski',\n    [Language.AF]: 'Afrikaans',\n};\n\n// Initialize i18n with new supported languages\ni18n.use(HttpBackend)\n    .use(LanguageDetector)\n    .use(initReactI18next)\n    .init({\n        lng: Language.EN,\n        compatibilityJSON: 'v4',\n        fallbackLng: Language.EN,\n        backend: {\n            loadPath: '/locales/{{lng}}/{{ns}}.json',\n        },\n        supportedLngs: [\n            Language.PL,\n            Language.AF,\n        ],\n        saveMissingTo: 'all',\n    });\n```\n\nSo there are four areas you would need to edit:\n* Within **export enum Language**, you will need to add your new localization's language code. You can do so by matching the two-letter code you noted in previous steps.\n* Within **switch (languageCode)**, you need to add the various regional locales that might map to your localization. This is usually a combination of the language code and the country code (derived from the ISO-3166(https://en.wikipedia.org/wiki/ISO_3166-1 codes). So for example, English would have 'en', 'en-GB', 'en-US' and so on to represent the variations available. This is appended **return Language.[YourCode]** which you defined in **export enum Language**\n* Within **export const LanguageList**, you'll need to include a line that tells the system what it should call the language in the Languages drop-down list. \n* Lastly, inside **supportedLngs:**, you'll need to add your language to the list.\n\nIf you're concerned or feel uncomfortable editing any of the above, you can skip it; the project maintainers will, if the localization is accepted, hook up your language in the system.\n\n## Step 6 - Duplicate an existing locale folder\nThe easiest way to get started is to duplicate one of the existing locale folders. You can skip this step if you are simply going to be editing an existing localization.\n\nFirst, check what the ISO-639 Set 1 code is for the language you are adding. You can get a [full list here](https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes).\n\nRight-click on the locale folder in VS Code's Explorer and select the **Create Folder** option. You will see a new, blank folder is created. Enter the two-letter code you noted earlier to create the folder.\n\nNext, select all the files in the **en** folder, right-click, and select **Copy**. Then, open your newly created folder, right-click, and select **Paste**. The files will be copied into the folder as new files. \n\nNote that each of these files has a **\"U\"** against it. You need to commit these changes to your local repository so that VS Code can start tracking changes against the files.\n\n> **_TIP:_** Commit changes often. Getting into the habit of committing your changes regularly ensures your changes are saved, making it easy to revert changes if required.\n\nGo to the Source Control tab and open up the Changes panel. The new folder and files you created will be listed here. You will need to commit these changes to the repository. In the comment section, provide a short comment explaining what the changes are - an example would be “Created template files and folder for Esperanto localization” - and press the **Commit** button.\n\n<img src=\"../assets/lessons/img/adding-languages/commit_sync_changes.png\" width=600>\n\nYou’ll be warned that this is not a staged commit and asked if you wish to commit this directly. Select **Yes** to continue. You’ll notice that the **Commit** button has changed to **Sync changes.** Doing this will sync the commits you’ve made to your remote repository on GitHub. You can click **Sync Changes** immediately, or make some additional commits before syncing.\n\n> **_TIP:_** While not necessary, Tari uses the conventional commits standard for commits. [A quick cheatsheet is available here](https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13). You will likely be mostly using feat, fix, and chore.\n\n## Step 7 - Edit the JSON files\nIf you have started a new localization, open the files created in the previous step. Otherwise, locate the existing localization you would like to edit and open those files. Regardless of the activity, as you work, save frequently and commit your changes, syncing as necessary. In addition, please keep the following guidelines in mind:\n* Avoid machine translation where possible. While workable, being fluent in the language is preferable.\n* Proofread your work to catch any errors you may introduce.\n* Do not translate specific references to underlying services, applications, or technologies. For example, xmrig and p2pool should be referred to as such regardless of the language being used.\n* Do not change any text that is within braces e.g. {{version}}\n\nBelow, you can find a description of what each JSON file affects within Tari Universe:\n|**File**|**Description**|\n|--------|---------------|\n|airdrop.json| Fields related to the Tari Airdrop game integration in Tari Universe|\n|common.json | Common terms used across the application, such as \"version\" and \"hashrate\" |\n|components.json| Component failure messages |\n|mining-view.json| UI of the main screen, and the status of the mining button |\n|settings.json| Text related to the Settings component of Tari Universe |\n|setup-view.json| Messages displayed when Tari Universe is booting up |\n|sidebar.json| UI elements in the sidebar of the main Tari Universe screen |\n|tribes-view.json| The title for the Squad View section in Settings. |\n\n## Step 8 - Creating a pull request (PR) for your localization\nOnce you’ve completed your localization changes, you will need to submit them via a pull request (PR) - essentially, an official Git request that asks the main project maintainers to review and incorporate your localization into the main project.\n\nBefore you begin this process, confirm that you have committed and synced all of your changes and double-check that no new locale variables have been added to the JSON files that you need to account for.\n\nThe easiest way to create a PR is via GitHub. Go to your fork on GitHub and make sure you have the branch you have been making the changes to selected. A message below the main title of the project will indicate that changes have been made, and give you an option to compare and create a PR.\n\n<img src=\"../assets/lessons/img/adding-languages/compare_pull_request.png\" width=500>\n\nClick on the **Compare & Pull Request** button to open the **Open a Pull Request** screen. The first thing to note is the block showing you which repositories and branches are being compared, and the direction of the changes. Yours should show an arrow pointing from your repository/branch to the main project, which indicates that this PR will \"pull\" your changes into the main project.\n\n<img src=\"../assets/lessons/img/adding-languages/pull_request_form.png\" width=600>\n\nBelow this is the form for capturing details about the PR. Follow these conventions when providing information:\n* The title of the PR should read, “Feat: added new localization for [your language]”\n* By default, GitHub has a standard template for capturing details against the PR. It’s best to follow the template when capturing info. You can refer to [this PR](https://github.com/tari-project/universe/pull/715) as a good example of the typical information provided.\n* Below the form and submission button is a summary of the changes that are being made.\n\nOnce you have completed the form, press the **Create pull request** button. This will both create a pull request and notify the maintainers that your code should be reviewed.\n\n> **_TIP:_** Once a PR has been submitted, be sure to follow up on the PR regularly. Reviewers may have questions or changes that need to be reviewed by you before they can continue. In this case, they will assign the PR back to you for action.\n\nIf the maintainers are happy with your additions, they will accept the PR and merge it into the main project. It might still be some time until the localization is incorporated into the main interface, though, so if it has been accepted, please be patient!\n\n# Conclusion\nAdding new localizations, or improving existing ones, ensures Tari Universe is easily useable by a wide audience.\n\n\n\n",
    "title": "Guide for adding new languages to the Tari Universe project",
    "order": 2,
    "excerpt": "At Tari, our approach has always leaned towards greater usability. Tari Universe, our desktop mining app, provides an easy entry point for those unfamiliar with the more complicated aspects of...",
    "thumbnail": "/assets/lessons/img/learn-the-tari-codebase.png",
    "author": "Solivagant"
  },
  {
    "slug": "06_tari_comms_i",
    "content": "\nIn this first lesson we will shed some light on the distributed peer-to-peer\n(p2p) networking crate [`tari_comms`](https://crates.io/crates/tari_comms/)\nand do a deeper dive into what makes it tick.\n\nSome of the higher level architecture has already been covered in [How Tari Works - Part I](/lessons/02_how_tari_works.html),\nso be sure to give that a read if you haven't already.\n\nIn this lesson we'll discuss:\n\n1. Transports\n1. The Anatomy of a Peer Connection\n1. Tor Integration\n1. The Messaging Protocol\n1. Building a Comms Stack\n\n## The `tari_comms` and `tari_comms_dht` crates\n\nUnderlying the Tari network are two crates, namely `tari_comms` and `tari_comms_dht`.\n\nAt it's core, `tari_comms` is responsible for\n\n-   keeping a peer list and\n-   establishing/accepting secure connections to/from those peers.\n\nThe `tari_comms_dht` crate contains the Tari DHT code and uses `tari_comms` to form a DHT network.\n\nIt provides interfaces that allow for peer discovery and\nmessage propagation, as well as a message pipeline (essentially inbound/outbound middlewares)\nthat processes message envelopes flowing to/from peers.\n\n## Overview\n\nThe `tari_comms` crate makes use of these wonderful technologies:\n\n-   TCP, Tor and SOCKS5 transports for reliable communcation,\n-   [`Multiaddr`](https://multiformats.io/multiaddr/) for self-describing and future-proof addressing of peers,\n-   the [noise protocol](https://noiseprotocol.org/noise.html) for encrypted peer connections and authentication,\n-   [`yamux`](https://github.com/hashicorp/yamux/blob/master/spec.md) for multiplexed communication over a single transport-level connection,\n-   [`LMDB`](http://www.lmdb.tech/doc/) for peer storage. In the near future, this may be replaced with SQLite to facilitate more complex queries,\n-   [`Protobuf`](https://developers.google.com/protocol-buffers) for structured data serialization over the wire,\n-   [`tokio`](https://docs.rs/tokio/) and [`futures-rs`](https://docs.rs/futures) for concurrency.\n\n## Building a Comms Stack\n\nThe first point of contact to the `tari_comms` crate is the `CommsBuilder` struct. This struct is an example\nof the commonly used [builder pattern](https://doc.rust-lang.org/1.0.0/style/ownership/builders.html).\n\nThe following is an example of constructing a comms node to illustrate what is required.\nA bit more work needs to be done to make this example work. If you would like to experiment with\na working example, checkout the tari repo and look in the examples folder in `comms/`.\n\n```\nuse tari_comms::CommsBuilder;\n\n#[tokio_macros::main]\nasync fn main() {\n  // Load a node identity from a file.\n  // The NodeIdentity struct contains the node's public/private key pair and publicly-accessible\n  // address.\n  let node_identity = load_node_identity();\n  let storage = setup_peer_storage();\n\n  let comms = CommsBuilder::new()\n    // Allow peers to use localhost as their address for testing purposes\n    .enable_test_addresses()\n    // The transport to use\n    .with_transport(TcpTransport::default())\n    // The address to listen for peer connections\n    .with_listener_address(\"/ip4/127.0.0.1/tcp/8080\".parse().unwrap())\n    // Set the identity of this node.\n    // This is used to authenticate via the noise protocol and when identity information is exchanged\n    .with_node_identity(node_identity)\n    // Set the peer list storage backend\n    .with_peer_storage(storage)\n    .build()\n    .expect(\"Failed to build comms\");\n\n  // The comms components are built, there may be some things you want to setup here before\n  // spawning the node\n\n  // Channel for outgoing messages. Send messages (`OutboundMessage`) on outbound_tx, and the messaging protocol will\n  // do it's best to send them to the correct peer in the peer list\n  let (_outbound_tx, outbound_rx) = mpsc::channel(10);\n  // Channel for incoming messages.\n  // Read `InboundMessage`s off the inbound_rx stream.\n  let (inbound_tx, _inbound_rx) = mpsc::channel(10);\n\n  let comms_node = comms\n      // Setup a messaging pipeline. This provides pipelines for incoming and outgoing messages. This is optional.\n      // You could add [tower services](https://docs.rs/tower-service/0.3.0/tower_service/trait.Service.html) (kind of like middleware) to\n      // process all incoming and outgoing messages.\n      .with_messaging_pipeline(\n         pipeline::Builder::new()\n            // Outbound messages will be forwarded \"as is\" to outbound messaging\n            .with_outbound_pipeline(outbound_rx, std::convert::identity)\n            .max_concurrent_inbound_tasks(1)\n            // Inbound messages will be forwarded \"as is\" to inbound_tx\n            .with_inbound_pipeline(SinkService::new(inbound_tx))\n            .finish(),\n    )\n    .spawn()\n    .await\n    .expect(\"Failed to spawn comms\");\n\n  do_things_with_comms(&comms_node).await;\n\n  // Shut everything down when done\n  comms_node.shutdown().await;\n}\n```\n\n## Transports\n\nEvery connection needs to start somewhere, and in the `tari_comms` crate it starts with the `Transport` trait.\nThis trait is an abstraction of the different methods that exist to transfer data between nodes.\nIt exposes two functions, namely `listen` and `dial`. Both of these functions take a single multi-address argument.\n\nEvery implementation of this trait needs to provide the code required to\n\n-   connect to an address (it's called `dial` to remind you to phone your grandmother)\n-   listen on the given address.\n\nOf course, not every kind of address is supported by every transport and the transport will error if given an address it does not know how to deal with. This is ok and part of the\n`Transport` contract.\n\nThe following `Transport` implementations are provided:\n\n-   `TcpTransport`\n\nThe `TcpTransport` listens on and establishes connections over TCP. Under the hood, it uses `tokio`'s asynchonous\n[`TcpStream`](https://docs.rs/tokio/0.1.12/tokio/net/struct.TcpStream.html).\n\nIt supports speaking the TCP protocol at IPv4 and IPv6 endpoints. In multi-address format, examples are `/ip4/1.2.3.4/tcp/18141` or `/ip6/::1/tcp/8080`.\n\n-   `SocksTransport`\n\nThis transport speaks the SOCKS5 protocol at the configured TCP address. Calls to `connect` are requested via the SOCKS5 protocol.\n\nWhen a Tari node is configured with the \"tor\" transport, it is actually using a `SocksTransport` that has been configured automatically\nto work with the tor proxy without the user having to configure it.\n\n-   `TcpWithTorTransport`\n\nThis transport composes the Tcp and Socks transport to allow nodes that are configured to connect and listen over TCP to communicate\nwith nodes that advertise Tor onion addresses exclusively.\n\nAll .onion addresses are routed through the `SocksTransport` and all TCP addresses are routed through the `TcpTransport`.\n\n-   `MemoryTransport`\n\nThe `MemoryTransport` mimics an internet socket without any I/O and is used extensively in unit and integration tests. Under the hood it uses `future-rs` mpsc channels and\ntherefore it can only transport data in-process. If you've used zeroMQ this is similar to the `inproc` transport.\n\nThe\n[_memorynet_ example](https://github.com/tari-project/tari/tree/development/comms/dht/examples/memory_net) in the `tari_comms_dht` code uses this transport to bring up a network of\nnodes that attempt to discover each other all in memory.\n\n## Anatomy of a p2p connection\n\nNow that we've covered the different transport options, let's take a deeper dive into how each p2p connection is established.\n\nFor the purposes of this section, let's invoke our _untrusted_ friends Alice and Bob. Alice (the initiator) wants\nto connect to Bob (the responder).\n\nThree guarantees are required for a connection between Alice and Bob.\n\n1. No private information, such as Alice's or Bob's public keys, are leaked to a (wo)man-in-the-middle during the handshake,\n1. once the connection is established, Alice is sure she is talking to Bob and vice versa, and\n1. any further communications sent between them is end-to-end encrypted.\n\nAlice already has Bob's public key and public address in her peer list. Bob may or may not know anything about Alice.\nShe begins by asking her configured transport to `dial` Bob on the address.\nAssuming Bob is online and listening, the connection is accepted.\nAt this point Bob has no idea who he is speaking to. Alice (as the initiator) has a few seconds to\nstart sending some speaking the protocol, or she'll be disconnected.\n\n### 1. Wire mode\n\nAlice starts by sending a single hard-coded byte that identifies that she wants to speak the protocol. This byte is the same for all nodes.\n\n### 2. Noise Protocol Handshake\n\nWithout delay, she begins the [noise protocol IX handshake](https://noiseprotocol.org/noise.html#interactive-handshake-patterns-fundamental).\n\nOnce both sides have completed their parts of the handshake, we say that the connection has been \"upgraded\".\nConnection upgrades are just another way of saying that both sides agree on how to continue communications.\nIn this case, both sides have agreed on how to encrypt further data sent between them.\n\nIn addition to this, the handshake has proven to Alice that she is speaking to Bob (or someone with Bob's private key).\n\n### 3. Multiplexing\n\nAt this point, Alice and Bob want to agree on a method for the various components to speak to each other at\nthe same time over the same connection without getting their messages mixed up. This is called multiplexing.\n`tari_comms` uses the [`yamux` protocol](https://github.com/hashicorp/yamux/blob/master/spec.md).\n\nFrom now on, both sides can negotiate many dedicated \"channels\" called _substreams_ on which to send data as needed.\nSubstreams are similar to a TCP socket. In fact, they implement the `AsyncRead` and `AsyncWrite` traits just as\ntokio TcpStream sockets do.\n\nMany Tari components use [the actor model](https://en.wikipedia.org/wiki/Actor_model), and communicate asynchonously using\nusing [MPSC](https://docs.rs/futures/0.3.4/futures/channel/mpsc/index.html) channels. Multiplexing and substreams\ncan be thought about in a similar way. A substream is a communication channel between an actor in Alice's node and\nan actor in Bob's node, allowing them to communicate as required over a single connection without having to concern\nthemselves with other messages sent over that connection.\n\n#### Negotiating a Substream\n\nIf Bob wants to open a new substream, Bob asks Alice to open a new channel. As the initiator of the substream, he must send let Alice know the protocol he wants to speak. A\nprotocol can be thought of as a language that both sides speak. Since there are typically many protocols that a system can speak, Bob (as the initiator) must send a protocol\nidentifier. In the Tari protocol, this is a string containing the name of the protocol and the version e.g. `/tari/messaging/1.0.0`, but this can be any string that identifies the\nprotocol. If Bob knows how to speak `Tari messaging protocol v1.0.0`, the negotiation succeeds and the actor that has registered its interest in the protocol is notified, and the\nconversation can begin. If not, Bob could try another protocol identifier or give up.\n\n### 4. Identity Exchange\n\nAt this point Alice and Bob are connected! That is, they both know how to open channels to each other over an\nencrypted connection! But wait... Bob knows Alice's public key. Great. But if Alice disconnected now, how would\nhe contact her again? Also, it seems a bit rude to connect and not introduce oneself wouldn't you say?\n\nLet's rectify this by speaking our first substream protocol: `/tari/identity/1.0.0`. Alice is the initiator, opens\nthe substream and Alice and Bob exchange details, such as their multi-addresses, their capabilities and the protocols\nthey speak. Both add or update those details in their peer lists and immediately close the substream.\n\nAfter all this has succeeded, the connection is active and is available for higher-level components.\n\n## The Messaging Protocol\n\nSubstreams are relatively low-level, so it makes sense to use them to build some higher-level communication protocols.\n`tari_comms` comes bundled with fire-and-forget style messaging (identified as `/tari/messaging/0.1.0`) and provides\na simple yet robust messaging interface. At the time of writing, this is the primary interface on which all base node,\nDHT and wallet messages are exchanged. In future, the community may decide to implement an RPC-style messaging protocol\nto remove the need for boilerplate when implementing request/response interactions.\n\nAt its essence (putting aside pipelines which we'll discuss later), the interface to this protocol is:\n\n1. Send a message to a peer\n1. Message received from a peer\n\nTwo `mpsc` channels are used, one for outgoing messages and one for incoming.\n\nFor each incoming message sent from a peer, an `IncomingMessage` struct is constructed and sent\non the incoming channel. The `IncomingMessage` struct contains the peer that sent it and the raw\nmessage body that higher-level components will presumably be able to interpret.\n\nSimilarly, for outgoing messages, the `OutboundMessage` struct contains the `NodeId`\nof the destination peer as well as the body/payload of the message to be sent.\n\nThe messaging protocol actor receives these messages where the following takes place:\n\n1. It asks the `ConnectionManager` for a connection to a peer matching the `NodeId`.\n1. In the meantime, all messages queued to be sent to this peer are queued up.\n1. Once it has the connection, it opens a substream speaking `/tari/messaging/0.1.0`.\n1. Once the substream is open, any queued messages are sent over to the receiving peer.\n\n### Message Framing\n\nBytes flowing over a transport are well and good, but how do you know when a complete message has been received?\nThis is where _framing_ comes into the picture.\n\nFraming is loosely-defined as a container for a payload of data. There are many schemes used in networking to delimit a frame.\nPerhaps the most basic one is _newline framing_ where each message is delimited by a newline character.\nOf course, this has limited utility (what happens if your message contains a newline?).\nA much more robust framing scheme, that is used in the Tari messaging protocol, is _length-delimited_ framing. As the name suggests,\neach frame is delimited with a `n` byte integer that specifies how much data to read to make up a single message.\n\n```text\n----------------------------------------------------------------------------------\n| len(msg1) |           msg1            | len(msg2) |           msg2             |\n----------------------------------------------------------------------------------\n```\n\n## Conclusion\n\n`tari_comms` has many features required to build a peer-to-peer network, so why not give it a try and let the community know what you think!\nIf you're a more hands-on individual and would like to contribute to `tari_comms` or the Tari codebase in general, the [good first issue](https://github.com/tari-project/tari/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22) label on the Tari github repo is a good place to start.\n\nLook out for the next post on the still-evolving Tari DHT crate.\n",
    "title": "Tari Comms - An In-depth Introduction",
    "order": 3,
    "excerpt": "In this first lesson we will shed some light on the distributed peer-to-peer (p2p) networking crate  and do a deeper dive into what makes it tick. Some of the higher level architecture has already...",
    "thumbnail": "/assets/lessons/img/learn-how-tari-works.png",
    "author": "Stanley Bondi"
  },
  {
    "slug": "05_emoji_id",
    "content": "\nThe `EmojiID` struct in the\n[`tari_wallet` crate](https://docs.rs/tari_wallet) provides everything you need to work with Tari's Emoji ID. In this\ntutorial, we will learn how to create an Emoji ID from a public key and vice versa. We will also validate an emoji ID\nagainst transcription errors.\n\n```\nuse tari_wallet::util::emoji::EmojiId;\nuse tari_crypto::tari_utilities::hex::Hex;\n\nfn main() {\n    const EMOJI: &str = \"🐎🍴🌷🌟💻🐖🐩🐾🌟🐬🎧🐌🏦🐳🐎🐝🐢🔋👕🎸👿🍒🐓🎉💔🌹🏆🐬💡🎳🚦🍹🎒\";\n    const EMOJI_SHORT: &str = \"🐎🍴🌷🌟💻🐖🐩🐾🌟🐬🎧🐌🏦🐳🐎🐝🐢🔋👕🎸👿🍒🐓🎉💔🌹🏆🐬💡🎳🚦🍹\";\n\n    // Convert a public key into its emoji ID\n    let eid = EmojiId::from_hex(\"70350e09c474809209824c6e6888707b7dd09959aa227343b5106382b856f73a\").unwrap();\n    println!(\"{}\",eid);\n\n    // Convert an emoji to public key (in hex)\n    let pubkey = EmojiId::str_to_pubkey(EMOJI).unwrap().to_hex();\n    println!(\"{}\", pubkey);\n\n    //Test if both constants declared at the top are valid\n    assert!(EmojiId::is_valid(EMOJI));\n    assert_eq!(EmojiId::is_valid(EMOJI_SHORT), false, \"Missing checksum\");\n    // TODO - check that emoji ID protects against transcription errors\n    println!(\"It's all good!\");\n}\n```\n\n```\n🖖🥴😍🙃💦🤘🤜👁🙃🙌😱🖐🙀🤳🖖👍✊🐈☂💀👚😶🤟😳👢😘😺🙌🎩🤬🐼😎🥺\n70350e09c474809209824c6e6888707b7dd09959aa227343b5106382b856f73a\nIt's all good!\n```\n",
    "title": "Working with Emoji Id",
    "order": 4,
    "excerpt": "The  struct in the  crate provides everything you need to work with Tari's Emoji ID. In this tutorial, we will learn how to create an Emoji ID from a public key and vice versa. We will also validate...",
    "thumbnail": "/assets/lessons/img/learn-emoji-id.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "04_how_tari_works_ii",
    "content": "\nLet’s lift the hood and look at what makes Tari tick.\n\nTari messages are serialised using\n[protobuf](https://developers.google.com/protocol-buffers), encrypted and sent over the wire. Tari nodes can advertise\nthemselves using IP addresses, or Tor hidden services. Tor is the default and is recommended; but if Tor doesn’t work\nfor some reason, you can revert to IPv4/6. However, you will likely have a degraded experience because IP nodes don’t\nknow about Tor nodes; only other IP nodes. On the other hand, Tor nodes can speak to both Tor and IP nodes. You can also\nexpose an IP address and connect to onion nodes using a local Tor proxy.\n\nTari nodes will build up a database of peer nodes over time. But the first time they run, they don’t know anybody, so\nhow does the new Tari node on the block make any friends? The answer is that there’s a hard-coded list of nodes that\n_should_ be running all the time included with the node or wallet installation. These nodes will bootstrap a node’s peer\ndatabase and introduce it to like-minded privacy and crypto aficionados in the node’s DHT neighbourhood.\n\nAs we discussed in the DHT section, distributed hash tables allow a network to make all the information on that network\ndiscoverable without requiring every node in it to hold a full copy of that information. A Tari node will only\nnecessarily share its peer information with peers in its local neighborhood.\n\nIf a remote peer wants to send you a message, for example a new Tari transaction, it will send a Discovery Request\nthrough the Tari network. Discovery Requests are inefficient. For privacy reasons, the sender is not identified in the\nclear and therefore the usual DHT approach of hopping ever-closer\n\nThe discovery request hops from peer to peer, getting closer to your neighbourhood on every hop, until a node is found\nthat knows who you are. That node will then contact your node directly to complete the transaction.\n\nBoth nodes will add each others’ contact information in their peer databases so that future communication is direct and\nvery fast. You’ll notice this when you first send Tari to a new contact (e.g. after scanning their pubkey from a QR\ncode), it may take 30s - 60s before the transaction appears in your transaction list. But the second and subsequent\ntimes you send Tari, the response is essentially instantaneous.\n\n\n### Sending Tari from Aurora\n\nWhen Alice sends Tari to Bob, she:\n\n1. selects his name from her address book,\n2. taps in the amount,\n3. clicks send.\n\n After a few seconds the transaction will appear in both their transaction pending lists and after a minute or two the\n transaction will be finalized.\n\nFrom a user perspective this is a seamless and very natural process that is actually fairly unique amongst\ncryptocurrency projects. For Tari Aurora we have focused heavily on user experience to make the sending and receiving of\nTari so natural that it feels no different to sending a message on WhatsApp or a payment over Venmo.\n\nHowever, under the hood a much more complex process and negotiation is taking place. The first thing that happens when\nAlice clicks the send button is that her wallet looks up the public key of the recipient, derived from his Emoji Id.\n\nWhether she typed in a name from her address book, pasted an emoji ID or scanned a QR code makes no difference to the\nTari wallet. All of these methods resolve to the same public key. If this public key is in Alice’s wallet’s peer\ndatabase then the wallet will try to establish a direct connection to Bob using the internet or onion address that is\nstored in Alice’s peer database.\n\nIf Bob’s public key is not in the peer database, then the wallet will issue a Discovery Request, described above, to the\nnetwork before a connection is initiated.\n\nOnce the connection between Alice and Bob has been made, the transaction negotiations can begin.\n\nAlice’s wallet will create an initial transaction that contains the amount she’s sending, change details and network\nfee. Alice's wallet software will then select a suitable set of UTXOs to pay for the transaction [^6], sign the\ntransaction, and send the partially completed transaction message over the network to Bob's wallet. On receipt of this\nmessage, Bob’s wallet will validate that the information provided is consistent with what it knows about the state of\nthe blockchain. It will complete the transaction by providing amongst other things a commitment for the amount of Tari\nthat it is receiving, which encodes Bob’s new spending key. Bob’s wallet will then sign this transaction and send it\nback to the original sender. Once Alice receives the signed response from Bob, her wallet will do some final checks and\nthen sign the completed transaction.\n\nAt this point the transaction is ready to be broadcast to the blockchain. This entails the node sending a copy of the\ntransaction to its peers. They in turn, will validate it, and if it is valid propagate it further to the rest of the\nnetwork.\n\nPhew. There’s a lot going on there. Here’s a sequence diagram illustrating this process:\n\n![transaction_protocol.svg](../assets/lessons/img/transaction_protocol.svg)\n\nEventually a mining node will find a new block and include this transaction in its transaction list for that block. At\nthis point the transaction can be considered somewhat finalized.\n\nObviously with any proof of work blockchain, no transaction is ever truly 100% finalized, but with every block that is\nadded to the chain, there is less and less chance that a transaction can be reversed.\n\nFor the purposes of user experience for testnet we are assuming that a transaction is considered finalised once it has\nbeen mined into the blockchain. As main net approaches and users become more familiar with the transaction flow, we may\nconsider expanding the definition of transaction finality to something that is more accurate in terms of traditional\nproof of work blockchain terminology.\n\n[^6]: Wallets can employ a variety of UTXO selection algorithms. Presently, the Tari wallet library has two very simple\nselection algorithms: Spend smallest first; and spend oldest first. “Spend oldest” first is the default algorithm.\n",
    "title": "How Tari Works - Part II",
    "order": 5,
    "excerpt": "Let’s lift the hood and look at what makes Tari tick. Tari messages are serialised using protobuf, encrypted and sent over the wire. Tari nodes can advertise themselves using IP addresses, or Tor...",
    "thumbnail": "/assets/lessons/img/learn-how-tari-works-2.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "03_signatures",
    "content": "\nFor details on the mathematics behind digital signatures,\n[Tari Labs University](https://tlu.tarilabs.com/cryptography/digital_signatures/introduction_schnorr_signatures.html)\nhas a good introduction.\n\nFor now let's have Alice sign a message and have Bob verify that it is from her.\n\nLet's assume that Alice has published her public key as `42b0c615e38cc7deaf574fd7127c8c58a3e654137415feb59770f3c110dca378`.\n\n```\nuse tari_crypto::{\n    keys::{PublicKey, SecretKey},\n    ristretto::{RistrettoPublicKey, RistrettoSecretKey, RistrettoSchnorr},\n    common::Blake256,\n};\n// Imports the to_hex trait method\nuse tari_utilities::hex::Hex;\n// imports the as_bytes trait method\nuse tari_utilities::byte_array::ByteArray;\nuse digest::Digest;\n\n/// The signature challenge is Hash(P || R || message)\nfn create_challenge(pubkey: &RistrettoPublicKey, r: &RistrettoPublicKey, msg: &str) -> Vec<u8> {\n    Blake256::new()\n        .chain(pubkey.as_bytes())\n        .chain(r.as_bytes())\n        .chain(msg.as_bytes())\n        .result()\n        .to_vec()\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let alice_k = RistrettoSecretKey::from_hex(\"df5f802bf33ff4d80198ec604b1413e25d1f53cd20fb4039901a7c34c1cafb0b\").unwrap();\n    let alice_p = RistrettoPublicKey::from_secret_key(&alice_k);\n    println!(\"Alice's public key is {}\", alice_p);\n    // Alice must generate a single-use random number for every signature\n    let (nonce, pub_nonce) = RistrettoPublicKey::random_keypair(&mut rng);\n    // The message to sign\n    let msg = \"Hello, Bob.\";\n    // TODO -- create the challenge\n    let e =\n    let sig =  RistrettoSchnorr::sign(alice_k, nonce, &e).unwrap();\n    let s = sig.get_signature().to_hex();\n    let r = sig.get_public_nonce().to_hex();\n    println!(\"Alice sends the message and signature to Bob:\\nmsg: {}\\nsig: {},{}\\n\\n\", msg, s, r);\n\n    // Now Bob wants to verify the signature\n    // TODO - recreate the public nonce for Bob using the hex values Alice provided\n    let r_bob = RistrettoPublicKey::...\n    let s_bob = RistrettoSecretKey::...\n    // Recreate Alice's public key from the value she publiched\n    let alice_pubkey = RistrettoPublicKey::from_hex(\"42b0c615e38cc7deaf574fd7127c8c58a3e654137415feb59770f3c110dca378\").unwrap();\n    // TODO - Bob has everything he needs to generate the challenge now\n    let e_bob = ...\n    // Create the signature instance\n    let sig_bob = RistrettoSchnorr::new(r_bob, s_bob);\n    let result = sig_bob.verify_challenge(&alice_pubkey, &e_bob);\n    if result {\n        println!(\"The message is signed by Alice\");\n    } else {\n        println!(\"Someone is trying to impersonate Alice!\");\n    }\n}\n```\n\n```\nAlice's public key is `42b0c615e38cc7deaf574fd7127c8c58a3e654137415feb59770f3c110dca378`\nAlice sends the message and signature to Bob:\nmsg: `Hello, Bob.`\nsig: `97938897220dcff9016af881d547d1ba1ef07b8465b1885f183c3872e142f40e`, `8e1cfbb2973d9d5b52e84816a78f6adc876b91d31cde7ea9cd16f1093927be4a`\nThe message is signed by Alice\n```\n",
    "title": "Signing a Message",
    "order": 6,
    "excerpt": "For details on the mathematics behind digital signatures, Tari Labs University has a good introduction. For now let's have Alice sign a message and have Bob verify that it is from her. Let's assume...",
    "thumbnail": "/assets/lessons/img/learn-signing-a-message.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "02_how_tari_works",
    "content": "\n\\- Hi. I’m 😂👻😿🖐⛑🐙 [^1]. This is literally all you need to know to send Tari to me on the network. Any time of\nday or night.\n\nNow hang on a minute; last I heard, Tari was a Mimblewimble-based cryptocurrency. Everybody knows that there's no such\nthing as an “address” in Mimblewimble. 😂👻😿🖐⛑🐙 looks an awful lot like an address, even if it is a cute and\ncuddly one. Not only that, but I heard that it's impossible to send coins using Mimblewimble without the other party\nbeing online.\n\n\\- Well yes, Tari makes use of the Mimblewimble protocol under the hood. But contrary to common belief, both parties\n   don’t need to be online simultaneously in order to transact in Tari. And you can reuse that same emoji ID that you\n   know and love over and over, without compromising your privacy or revealing your identity.\n\n\\- Let’s see how Tari achieves this.\n\n[^1]: Names have been changed to protect the victims of tragic boating accidents.\n\n\n## The Tari DHT network\n\nThe Tari communications stack, or comms stack, as we like to call it, is the technology behind the Tari peer-to-peer\nmessaging network. All Tari base nodes, wallets and (eventually) validator nodes are first-class citizens on this\nnetwork.\n\nEach node maintains a database of other peers they know about, but not necessarily all of the peers in the network.\n\n![dht.png](../assets/lessons/img/dht.png)\n\nWhen viewed as a whole, the Tari network comprises overlapping neighbourhoods, with every node knowing about a few other\npeers in its immediate vicinity. When a node needs to contact another peer that it doesn't know, it will send a\n“Discovery Request” through the network. Nodes will pass the message along, getting closer and closer to the recipient\nuntil someone is able to pass the message on to the intended destination. At this point the recipient will make direct\ncontact with the original sender and from that point on the two will communicate via end-to-end encryption.\n\nIt's a bit like when you wanted to send a note to someone on the other side of the class in grade school. You would fold\nit up and ask the person next to you to pass it on. The difference is that in grade school the intermediaries would open\nup your note and read what you had written there. On the Tari network, the messages are encrypted so that no one can\nread the message. All they know is who the recipient is. They do not know what the message contains or who it is from.\nThis is done using an encryption protocol called asymmetric\n[ECC encryption](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecc-encryption-decryption).[^2]\n\nThis bears repeating: In a discovery message, it does mean that some nodes on the network will know that there is a\nmessage being sent to the destination peer, but they will not know its contents, nor will they know from where the\nmessage originated.\n\nThis type of network is called a distributed hash table. It’s based on a technology called\n[Kademlia](https://en.wikipedia.org/wiki/Kademlia) and is very similar to how Bitorrent finds the, uh, totally\nlegitimate bits of files they’re downloading from disparate parts of the internet.\n\nThe upside of all of this is that anyone can find anyone else on the Tari network without\n\n1. Any servers or central databases,\n2. Having to keep a database of the entire network; you only need to track the peers in your neighbourhood.\n\nThis is great for privacy because there’s no central point of failure to get hacked and have the information sold on the\ndark web; no trove of relationship data to sell to state apparatus to influence elections; no risk of catastrophic\nhardware failure causing the entire network to collapse.\n\nOn the downside, it’s significantly slower than a central database. You can find anyone on a centralised social network\nwith a single lookup; while a lookup on the DHT takes log(n) queries. In practise, peer lookups on the Tari network can\ntake up to 60 seconds, especially with the added complexity of Tor thrown into the mix.\n\n[^2]: An earlier version of the comms stack used symmetric encryption with a shared Diffie-Hellman key, which meant that the sender had to share his public key with the message; so everyone one would know that Alice was sending a message to Bob. We got tired of the gossip and speculation that there was something going on between those two, so we switched to the more private method.\n\n\n### Tari and Tor\n\nTor is [The Onion Router](https://www.torproject.org/).\n\nIt’s called the onion router because it\n[makes spies cry.](https://blog.torproject.org/thank-you-edward-snowden-tor) In actual fact, it’s called onion routing\nbecause messages are wrapped in layers of encryption. Each layer, like a high-tech game of pass the parcel, is only able\nto be unwrapped by a specific intermediary. When an intermediary unwraps a message, the details of another intermediary\nare revealed. And the parcel gets passed around the internet until the final layer reveals the final destination of the\nmessage. We wrote a fairly in-depth article about Tor at\n[Tari Labs University](https://tlu.tarilabs.com/protocols/intro-to-tor-i2P/MainReport.html#tor-network).\n\nTari nodes use Tor by default. The advantages of Tor are manifold:\n\nFirstly, Tor preserves your privacy by hiding your IP address from anyone snooping on the network’s traffic.\n\nSecondly, Tor enables users behind firewalls to access the network without having to configure their routers or open\nports on their LAN.\n\nAnd finally, Tor is what allows us to have mobile phones connect directly to each other on the Tari network without\nhaving to go through a proxy server.\n\nThis last feature is what sets Tari aside from most other cryptocurrency projects that ship with mobile wallets,\nincluding the Bitcoin Lightning Network. Lightning wallets cannot open channels directly from phone to phone over the\nwider internet, but have to go through a server-based lightning router. Try it. I’ll wait.\n\nIt’s a bit of a pain, isn’t it? This is a major usability drawback and one which Tari is proud to have solved to some degree [^3].\n\nThe drawback of using Tor, as we mentioned above is that all this bouncing around the internet makes the Tari network\nsignificantly slower. But you know what? It’s a bit like those cosmetics products: worth it.\n\n[^3]: We haven’t solved it fully; wallets do need to talk to a node to obtain blockchain information for some things, including watching for transaction confirmations, but we have some ideas on how to reduce this in the future.\n\n\n## How do we have “addresses”? I thought Tari used Mimblewimble.\n\nWhen you send someone Bitcoin to someone’s address, what you’re really doing is locking up a UTXO with a cryptic message\nsaying `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG. `Like when Harry Potter uncovers some ancient vessel\ncontaining a scroll with the message “whosoever knows the number corresponding to the public key described herein may\nseek their riches”; it’s basically the same thing. You’re not really sending Bitcoin to a mailbox; you’re leaving a\nchallenge open to the public that whoever can provide proof that they know the private key corresponding to the public\nkey in the script, the locked up bitcoin is theirs. Maybe it’s more Sword in the Stone; I was never a big fantasy guy.\n\nSpeaking of Harry Potter, Mimblewimble doesn’t have a concept of addresses. There’s no scripting in Mimblewimble, and\n[participants in a transaction have to interact](https://tlu.tarilabs.com/protocols/mimblewimble-1/MainReport.html)\nbefore it can be broadcast to the network.\n\nSo how does Tari claim to have a single, long-lived identifier, your emoji id, to handle all your transactions.\n\nThe trick is that your emoji id is really an address, more so than a Bitcoin address.\n\nPeers on the network are identified via a unique public key. When a wallet or node registers on the network, it makes\nthe announcement, “Hi, I’m 😂👻😿🖐⛑”. That id is your identifier on the Tari DHT, and determines which\nneighbourhood your node is in and allows other nodes and wallets to find you on the network as was described in the\nsection on the DHT.\n\nSo where does this id come from? Can I choose my own? I mean, that id is great, but I really want to have 🐴❤️🔑⛵️😢\nas my emoji. The short answer is that you don’t get to choose your emoji id [^4].\n\nWhat's actually happening is that when a wallet gets created a master seed is used. This seed is literally the key to\nyour entire Tari identity and wealth, so it’s really important to keep it safe.\n\nEverything is derived from this seed, including your emoji id as well as every private key that is used in Tari\ntransactions.\n\nThis is behind the magic that lets it look like you have a Tari address. The emoji id, which is tied to your master\nseed, allows your friends and family to find you on the network; which solves the interaction part of the Mimblewimble\ntransaction. The seed is also used to generate as many private keys as we like to use in transactions; which solves the\nsecond part.\n\nAs long as you know your master seed, you can reconstruct your identity and wallet balance on another device.\n\n### Staged Security\n\nAt this stage you may be asking yourself why you weren't asked to back up your seed phrase when you installed the Tari\nwallet on your device. Most crypto wallets ask users to back up their seed phrase the first time they use the app. Why\ndidn’t we?\n\nWhat is this, a New York nightclub? We aren’t going to charge you just to get into the door. You just want to look\naround without being hassled. There’s no value in the wallet, so what’s the risk?\n\nAs if stopping the onboarding flow by asking users to back up a phrase isn’t bad enough -- on paper mind you, we’re\nwatching to make sure that you don't do something silly like take a screenshot. Some wallets even force their users to\nwrite a test before letting them into the app. A test? Really? Guys, where is the trust?\n\nHonestly, when new users have a new app in front of them what they really want to do is get involved and play with it as\nsoon as possible. I’m sure I’m not alone when I say I’ve uninstalled plenty of crypto wallets because of the hoops the\ndevelopers try to make me jump through to keep my huge balance of zero safu. Tari Aurora simply gets out of the user’s\nway and let’s you play with the technology and the cryptocurrency immediately while there is little to no value stored\non the wallet.\n\nIt’s still really important to keep that master seed safe. I said that very thing eight paragraphs back. I stand by\nthat. It’s just not that critical when you have a zero balance.\n\nOnce the balance of your wallet exceeds a certain value the app will then prompt you to backup your seed phrase. At this\npoint you will be familiar with the app and how it works. This is the right time for us to start to nudge you to take\nmore precautions about the funds that are stored on your wallet.\n\nI’ll bet that asking users to do things like backup a seed phrase too early on in their exploration process is actually\ndetrimental. They will either not back it up (and say they did) in which case the phrase is lost, or they comply not\nknowing what the hell it is they’re doing and “back the phrase up” by emailing it to themselves, or posting it on\nInstragram or doing any of a million other dumb things we all did when we first started our journey into crypto.\n\nFor Tari, we believe that the staged approach to security is better from _both_ a user experience as well as from a\nsecurity point of view in the long run [^5].\n\n[^4]: But we have some pretty exciting ideas on how this can change in the future.\n\n[^5]: The current testnet version of Tari Aurora does not have the staged security process. This feature is planned ahead of the mainnet release version.\n",
    "title": "How Tari Works - Part I",
    "order": 7,
    "excerpt": "\\- Hi. I’m 😂👻😿🖐⛑🐙 [^1]. This is literally all you need to know to send Tari to me on the network. Any time of day or night. Now hang on a minute; last I heard, Tari was a Mimblewimble-based...",
    "thumbnail": "/assets/lessons/img/learn-how-tari-works.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "01_keys",
    "content": "\nThe [tari_crypto](https://docs.rs/tari_crypto) crate carries the fundamental Tari cryptography primitives. It wraps the\nRistretto elliptic curve, and provides ergonomic methods for using private and public keys, Pedersen commitments and\ndigital signatures.\n\n```\nuse tari_crypto::ristretto::{ RistrettoSecretKey as SecretKey, RistrettoPublicKey as PublicKey };\nuse tari_utilities::hex::Hex; use tari_crypto::keys::PublicKey as PK;\n\nfn main() {\n    // Create the secret key 1;\n    let k = SecretKey::from_hex(\"0000000000000000000000000000000000000000000000000000000000000001\").unwrap();\n    // Generate the public key, P = k.G\n    let pubkey = PublicKey::from_secret_key(&k);\n    println!(\"{}\", pubkey)\n}\n```\n\n```\nbec7f50a7307aff31eef64789bcd50e996e4b16b9f974cabef4800add830392f\n```\n",
    "title": "Introduction to Keys",
    "order": 8,
    "excerpt": "The taricrypto crate carries the fundamental Tari cryptography primitives. It wraps the Ristretto elliptic curve, and provides ergonomic methods for using private and public keys, Pedersen...",
    "thumbnail": "/assets/lessons/img/learn-intro-to-keys.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "00_introduction",
    "content": "\nWe're so excited that you want to help make Tari even better. We also realise that blockchain codebases can be pretty\nintimidating. This is where this blog comes in.\n\nThe articles in this blog are aimed squarely at developers that want to get involved with the project, but don't know\nwhere to start.\n\nThe articles here are reasonably technical, and cover different parts of the Tari codebase. There are also executable\nsections of code that let you play with the Tari modules without even having to leave your browser.\n\nClick the ▶️ button in the top-right corner of the code snippets and wait for the result.\n\n```\nfn main() {\n    println!(\"Damn, that's so cool!\");\n}\n```\n\nThe code is completely editable too, so go ahead and try some Rust code out! We've included the top 100 crates as well\nas all the Tari crates into the virtual machine so you can run almost[^1] anything you like.\n\nIf you mess up, not to worry! The ⟲ icon will put the code the way you found it.\n\nFinally, you can copy your masterpieces to the clipboard with the Copy button.\n\nHappy coding!\n\n[^1]: Almost anything. The code must compile inside a minute, and there are no networking features supported.\n",
    "title": "Learning the Tari Codebase",
    "order": 9,
    "excerpt": "We're so excited that you want to help make Tari even better. We also realise that blockchain codebases can be pretty intimidating. This is where this blog comes in. The articles in this blog are...",
    "thumbnail": "/assets/lessons/img/learn-the-tari-codebase.png",
    "author": "Cayle Sharrock"
  },
  {
    "slug": "00a_Execute_Tari_Node_Windows_10",
    "content": "\n\nSo you want to run a Tari node? Whether you want to mine for Tari or just run a node, this complete guide will have you up and running in no time.\n\n\n## Step 1: Downloading and installing the Tari Windows Binaries\n\n\n### Downloading the binary\n\nGo to [https://www.tari.com/downloads/](https://www.tari.com/downloads/), click on the Windows tab, then click on the Download for Windows button.\n\n\n\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/download-page.png)\n\n\nSave it to your downloads folder, or a place where you can easily remember where it is and how to find it.\n\n**Do not run the exe just yet!** We should verify the SHA256 hash of your exe first.\n\n\n### Verifying Tari’s hash\n\nGo to the folder where you downloaded your exe.\n\n![Downloads Lesson Graphic](../assets/lessons/img/verify-hash.png)\n\n\nIn the address bar, type \"cmd\" (without quotes)\n\n![Downloads Lesson Graphic](../assets/lessons/img/cmd.png)\n\n\nThis will open command prompt. Type in \"sha256sum NameOfTariExe.exe\" (without quotes). For example, if the Tari exe was called \"tari_base_node-windows-0.2.1-ecfe782\", you would type in \"sha256sum tari_base_node-windows-0.2.1-ecfe782.exe\" (without quotes).\n\nHere are two hints to make this easier:\n- You can copy the text sha256sum and then use Ctrl + V to paste the text into command prompt. \n- If you press the Tab key, Windows will autofill any text you wrote in with what it thinks you are trying to type. \n\nWriting  \"sha256sum tari_base_node-windows-0.2.1-ecfe782.exe\" by hand is a lot of work, but if you were to write \"sha256sum tari\" and then press Tab, Windows will do the rest of the work for you. Keep in mind; however, if you have other files that start with the name Tari, they may show up before the one you are looking for.\n\nOnce you typed it all in, press enter and you will see a long string of numbers. Back to [https://www.tari.com/downloads/](https://www.tari.com/downloads/), under the Download for Windows button, you will see \"SHA256:\" and a long string of numbers. Verify that these two numbers match. If you want to be extra sure you have the right numbers, disconnect a mobile phone from your home wifi and check the Tari page from there.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/hash-rate.png)\n\n\n\n### Installing Tari\n\nRun the Tari exe. If you get a message from Microsoft Defender SmartScreen saying \"Windows Protected your PC, click on More info, then Run anyway.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/install-1.png)\n\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/install-2.png)\n\n\nIf you get a message from User Account Control asking if you want to allow this app to make changes to your device, click Yes.\n\nRead and agree to the short License.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/license-agreement.png)\n\n\nSave the location of the Tari install for later\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/location-install.png)\n\n\nYou can have Tari create a start menu folder if you'd like, but we won't be using it for this tutorial.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/start-menu.png)\n\n\nYou can have Tari create a desktop shortcut if you'd like, but we won't be using it for this tutorial.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/desktop-shortcut.png)\n\n\nClick install\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/ready-to-install.png)\n\n\nPress Next\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/install-next.png)\n\n\nMake sure all are clicked and press Finish\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/install-wizard.png)\n\n\nTari will now start downloading extra dependency automatically. Once you get to Microsoft Visual C++ Redistributable, you'll have to click to install and then click the restart button when asked. This will restart your computer. You can also click close and restart your computer later, but make sure to restart before continuing this tutorial.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/extra-dependency.png)\n\n\n\n## Step 2: Configure Tari\n\nBefore we can configure Tari, lets make sure we know how to find Tari. If you saved the location of the Tari install from the previous step, then your good. If not, you can find Tari by pressing the Windows Key + R, which will open up a program called \"Run\". In that program type \"%USERPROFILE%\" (without quotes).\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/configure-tari.png)\n\n\nThis will open a file explorer with a bunch of folders. The one we are looking for is called \".tari-testnet\"\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/file-explorer.png)\n\n\n\n### Storing the Tari blockchain on a second hard drive\n\nYou can skip this step if you want to store the Tari Blockchain on your main hard drive. \n\nThe current version of Tari for Windows requires around 100GB of free space in order to run. If your main C: drive doesn't have this much space, or you rather not store the blockchain on your main drive, you may wish to use a secondary drive instead. You can check how much space your hard drive has by pressing the window key and typing \"This PC\"\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/store-location.png)\n\n\nInside of the \".tari-testnet\" folder, there is a folder called \"config\". Inside of that folder there is a file called \"windows.toml\". Open this file in your text editor of choice. Search for the text (data_dir=\"rincewind\") (without parenthesis). To save the blockchain on your D drive, place that text with this  (data_dir=\"d:\\\\tari\\\\rincewind\") (without parenthesis). If you wish to use any other letter drive, replace the D with the letter you are using.\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/store-path.png)\n\n\n\n### Mining Tari\n\nYou can skip this step if you don't plan on mining Tari.\n\nInside of the \".tari-testnet\" folder, there is a folder called \"config\". Inside of that folder there is a file called \"windows.toml\". Open this file in your text editor of choice. Search for the text \"num_mining_threads = 1\" (without quotes). Change the 1 to however many threads you want your CPU to mine with. You can look up how many threads your CPU has if you want to mine with all of them. If you don't know what CPU you have press the window key and type \"This PC\" but instead of clicking on This PC, right-click it instead and click on properties\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/mine-tari.png)\n\n\n\n\n![Downloads Lesson Graphic](../assets/lessons/img/processor.png)\n\n\n\n## Step 3: Running Tari\n\nMake sure you save your config file before closing it if you made any changes to it.\n\nInside of the \".tari-testnet\" folder, there is a folder called \"runtime\". Inside of that folder, there is a batch file called \"start_tari_basenode\". Run it. You will soon be asked a question. \"Logging configuration file does not exist. Would you like to create a new one (Y/n)?\" Type Y and press enter.\n\n![Downloads Lesson Graphic](../assets/lessons/img/running-tari.png)\n\nYou are now connected to the Tari network! If you use the list-peers command you will see your connections to other nodes. Once your node is done syncing it will start mining. You can use the toggle-mining command to change this.\n\n",
    "title": "How to run a Tari Node on Windows 10",
    "order": 10,
    "excerpt": "So you want to run a Tari node? Whether you want to mine for Tari or just run a node, this complete guide will have you up and running in no time. Step 1: Downloading and installing the Tari Windows...",
    "thumbnail": "/assets/lessons/img/learn-how-tari-works-2.png",
    "author": "Blue. Edited by Natasha Haripersad."
  }
]